{"version":3,"file":"ngx-uploader.umd.min.js","sources":["~/ngx-uploader/src/ngx-uploader/classes/ngx-uploader.class.ts","~/ngx-uploader/src/ngx-uploader/classes/interfaces.ts","~/ngx-uploader/src/ngx-uploader/directives/ng-file-select.directive.ts","~/ngx-uploader/src/ngx-uploader/directives/ng-file-drop.directive.ts","~/ngx-uploader/src/ngx-uploader/module/ngx-uploader.module.ts"],"sourcesContent":["import { EventEmitter } from '@angular/core';\nimport { Observable } from 'rxjs/Observable';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\nimport'rxjs/add/operator/mergeMap';\nimport { UploadFile, UploadOutput, UploadInput, UploadStatus, BlobFile } from './interfaces';\n/**\n * @param {?} bytes\n * @return {?}\n */\nexport function humanizeBytes(bytes: number): string {\n  if (bytes === 0) {\n    return '0 Byte';\n  }\n\n  const /** @type {?} */ k = 1024;\n  const /** @type {?} */ sizes: string[] = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];\n  const /** @type {?} */ i: number = Math.floor(Math.log(bytes) / Math.log(k));\n\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n}\nexport class NgUploaderService {\n  queue: UploadFile[];\n  serviceEvents: EventEmitter<UploadOutput>;\n  uploadScheduler: Subject<{ file: UploadFile, event: UploadInput }>;\n  subs: { id: string, sub: Subscription }[];\n  contentTypes: string[];\n/**\n * @param {?=} concurrency\n * @param {?=} contentTypes\n */\nconstructor(concurrency: number = Number.POSITIVE_INFINITY, contentTypes: string[] = ['*']) {\n    this.queue = [];\n    this.serviceEvents = new EventEmitter<any>();\n    this.uploadScheduler = new Subject();\n    this.subs = [];\n    this.contentTypes = contentTypes;\n\n    this.uploadScheduler\n      .mergeMap(upload => this.startUpload(upload), concurrency)\n      .subscribe(uploadOutput => this.serviceEvents.emit(uploadOutput));\n  }\n/**\n * @param {?} incomingFiles\n * @return {?}\n */\nhandleFiles(incomingFiles: FileList): void {\n    const /** @type {?} */ allowedIncomingFiles: File[] = [].reduce.call(incomingFiles, (acc: File[], checkFile: File, i: number) => {\n      if (this.isContentTypeAllowed(checkFile.type)) {\n        acc = acc.concat(checkFile);\n      } else {\n        const /** @type {?} */ rejectedFile: UploadFile = this.makeUploadFile(checkFile, i);\n        this.serviceEvents.emit({ type: 'rejected', file: rejectedFile });\n      }\n\n      return acc;\n    }, []);\n\n    this.queue.push(...[].map.call(allowedIncomingFiles, (file: File, i: number) => {\n      const /** @type {?} */ uploadFile: UploadFile = this.makeUploadFile(file, i);\n      this.serviceEvents.emit({ type: 'addedToQueue', file: uploadFile });\n      return uploadFile;\n    }));\n\n    this.serviceEvents.emit({ type: 'allAddedToQueue' });\n  }\n/**\n * @param {?} input\n * @return {?}\n */\ninitInputEvents(input: EventEmitter<UploadInput>): Subscription {\n    return input.subscribe((event: UploadInput) => {\n      switch (event.type) {\n        case 'uploadFile':\n          const /** @type {?} */ uploadFileIndex = this.queue.findIndex(file => file === event.file);\n          if (uploadFileIndex !== -1 && event.file) {\n            this.uploadScheduler.next({ file: this.queue[uploadFileIndex], event: event });\n          }\n        break;\n        case 'uploadAll':\n          const /** @type {?} */ files = this.queue.filter(file => file.progress.status === UploadStatus.Queue);\n          files.forEach(file => this.uploadScheduler.next({ file: file, event: event }));\n        break;\n        case 'cancel':\n          const /** @type {?} */ id = event.id || null;\n          if (!id) {\n            return;\n          }\n\n          const /** @type {?} */ index = this.subs.findIndex(sub => sub.id === id);\n          if (index !== -1 && this.subs[index].sub) {\n            this.subs[index].sub.unsubscribe();\n\n            const /** @type {?} */ fileIndex = this.queue.findIndex(file => file.id === id);\n            if (fileIndex !== -1) {\n              this.queue[fileIndex].progress.status = UploadStatus.Cancelled;\n              this.serviceEvents.emit({ type: 'cancelled', file: this.queue[fileIndex] });\n            }\n          }\n        break;\n        case 'cancelAll':\n          this.subs.forEach(sub => {\n            if (sub.sub) {\n              sub.sub.unsubscribe();\n            }\n\n            const /** @type {?} */ file = this.queue.find(uploadFile => uploadFile.id === sub.id);\n            if (file) {\n              file.progress.status = UploadStatus.Cancelled;\n              this.serviceEvents.emit({ type: 'cancelled', file: file });\n            }\n          });\n        break;\n        case 'remove':\n          if (!event.id) {\n            return;\n          }\n\n          const /** @type {?} */ i = this.queue.findIndex(file => file.id === event.id);\n          if (i !== -1) {\n            const /** @type {?} */ file = this.queue[i];\n            this.queue.splice(i, 1);\n            this.serviceEvents.emit({ type: 'removed', file: file });\n          }\n        break;\n        case 'removeAll':\n          if (this.queue.length) {\n            this.queue = [];\n            this.serviceEvents.emit({ type: 'removedAll' });\n          }\n        break;\n      }\n    });\n  }\n/**\n * @param {?} upload\n * @return {?}\n */\nstartUpload(upload: { file: UploadFile, event: UploadInput }): Observable<UploadOutput> {\n    return new Observable(observer => {\n      const /** @type {?} */ sub = this.uploadFile(upload.file, upload.event)\n        .subscribe(output => {\n          observer.next(output);\n        }, err => {\n          observer.error(err);\n          observer.complete();\n        }, () => {\n          observer.complete();\n        });\n\n      this.subs.push({ id: upload.file.id, sub: sub });\n    });\n  }\n/**\n * @param {?} file\n * @param {?} event\n * @return {?}\n */\nuploadFile(file: UploadFile, event: UploadInput): Observable<UploadOutput> {\n    return new Observable(observer => {\n      const /** @type {?} */ url = event.url || '';\n      const /** @type {?} */ method = event.method || 'POST';\n      const /** @type {?} */ data = event.data || {};\n      const /** @type {?} */ headers = event.headers || {};\n\n      const /** @type {?} */ xhr = new XMLHttpRequest();\n      const /** @type {?} */ time: number = new Date().getTime();\n      let /** @type {?} */ progressStartTime: number = (file.progress.data && file.progress.data.startTime) || time;\n      let /** @type {?} */ speed = 0;\n      let /** @type {?} */ eta: number | null = null;\n\n      xhr.upload.addEventListener('progress', (e: ProgressEvent) => {\n        if (e.lengthComputable) {\n          const /** @type {?} */ percentage = Math.round((e.loaded * 100) / e.total);\n          const /** @type {?} */ diff = new Date().getTime() - time;\n          speed = Math.round(e.loaded / diff * 1000);\n          progressStartTime = (file.progress.data && file.progress.data.startTime) || new Date().getTime();\n          eta = Math.ceil((e.total - e.loaded) / speed);\n\n          file.progress = {\n            status: UploadStatus.Uploading,\n            data: {\n              percentage: percentage,\n              speed: speed,\n              speedHuman: `${humanizeBytes(speed)}/s`,\n              startTime: progressStartTime,\n              endTime: null,\n              eta: eta,\n              etaHuman: this.secondsToHuman(eta)\n            }\n          };\n\n          observer.next({ type: 'uploading', file: file });\n        }\n      }, false);\n\n      xhr.upload.addEventListener('error', (e: Event) => {\n        observer.error(e);\n        observer.complete();\n      });\n\n      xhr.onreadystatechange = () => {\n        if (xhr.readyState === XMLHttpRequest.DONE) {\n          const /** @type {?} */ speedAverage = Math.round(file.size / (new Date().getTime() - progressStartTime) * 1000);\n          file.progress = {\n            status: UploadStatus.Done,\n            data: {\n              percentage: 100,\n              speed: speedAverage,\n              speedHuman: `${humanizeBytes(speedAverage)}/s`,\n              startTime: progressStartTime,\n              endTime: new Date().getTime(),\n              eta: eta,\n              etaHuman: this.secondsToHuman(eta || 0)\n            }\n          };\n\n          file.responseStatus = xhr.status;\n\n          try {\n            file.response = JSON.parse(xhr.response);\n          } catch ( /** @type {?} */e) {\n            file.response = xhr.response;\n          }\n\n          file.responseHeaders = this.parseResponseHeaders(xhr.getAllResponseHeaders());\n\n          observer.next({ type: 'done', file: file });\n\n          observer.complete();\n        }\n      };\n\n      xhr.open(method, url, true);\n      xhr.withCredentials = event.withCredentials ? true : false;\n\n      try {\n        const /** @type {?} */ uploadFile = /** @type {?} */(( <BlobFile>file.nativeFile));\n        const /** @type {?} */ uploadIndex = this.queue.findIndex(outFile => outFile.nativeFile === uploadFile);\n\n        if (this.queue[uploadIndex].progress.status === UploadStatus.Cancelled) {\n          observer.complete();\n        }\n\n        Object.keys(data).forEach(key => file.form.append(key, data[key]));\n        Object.keys(headers).forEach(key => xhr.setRequestHeader(key, headers[key]));\n\n        file.form.append(event.fieldName || 'file', uploadFile, uploadFile.name);\n\n        this.serviceEvents.emit({ type: 'start', file: file });\n        xhr.send(file.form);\n      } catch ( /** @type {?} */e) {\n        observer.complete();\n      }\n\n      return () => {\n        xhr.abort();\n      };\n    });\n  }\n/**\n * @param {?} sec\n * @return {?}\n */\nsecondsToHuman(sec: number): string {\n    return new Date(sec * 1000).toISOString().substr(11, 8);\n  }\n/**\n * @return {?}\n */\ngenerateId(): string {\n    return Math.random().toString(36).substring(7);\n  }\n/**\n * @param {?} contentTypes\n * @return {?}\n */\nsetContentTypes(contentTypes: string[]): void {\n    if ( typeof contentTypes != 'undefined' && contentTypes instanceof Array ) {\n      if (contentTypes.find((type: string) => type === '*') !== undefined) {\n        this.contentTypes = ['*'];\n      } else {\n        this.contentTypes = contentTypes;\n      }\n      return;\n    }\n    this.contentTypes = ['*'];\n  }\n/**\n * @return {?}\n */\nallContentTypesAllowed(): boolean {\n    return this.contentTypes.find((type: string) => type === '*') !== undefined;\n  }\n/**\n * @param {?} mimetype\n * @return {?}\n */\nisContentTypeAllowed(mimetype: string): boolean {\n    if (this.allContentTypesAllowed()) {\n      return true;\n    }\n    return this.contentTypes.find((type: string) => type === mimetype) !== undefined;\n  }\n/**\n * @param {?} file\n * @param {?} index\n * @return {?}\n */\nmakeUploadFile(file: File, index: number): UploadFile {\n    return {\n      fileIndex: index,\n      id: this.generateId(),\n      name: file.name,\n      size: file.size,\n      type: file.type,\n      form: new FormData(),\n      progress: {\n        status: UploadStatus.Queue,\n        data: {\n          percentage: 0,\n          speed: 0,\n          speedHuman: `${humanizeBytes(0)}/s`,\n          startTime: null,\n          endTime: null,\n          eta: null,\n          etaHuman: null\n        }\n      },\n      lastModifiedDate: file.lastModifiedDate,\n      sub: undefined,\n      nativeFile: file\n    };\n  }\n/**\n * @param {?} httpHeaders\n * @return {?}\n */\nprivate parseResponseHeaders(httpHeaders: ByteString) {\n    if (!httpHeaders) {\n      return;\n    }\n    return httpHeaders.split('\\n')\n      .map(x => x.split(/: */, 2))\n      .filter(x => x[0])\n      .reduce((ac, x) => {\n        ac[x[0]] = x[1];\n        return ac;\n      }, {});\n  }\n}\n\nfunction NgUploaderService_tsickle_Closure_declarations() {\n/** @type {?} */\nNgUploaderService.prototype.queue;\n/** @type {?} */\nNgUploaderService.prototype.serviceEvents;\n/** @type {?} */\nNgUploaderService.prototype.uploadScheduler;\n/** @type {?} */\nNgUploaderService.prototype.subs;\n/** @type {?} */\nNgUploaderService.prototype.contentTypes;\n}\n\n","import { Subscription } from 'rxjs/Subscription';\n\nexport interface UploaderOptions {\n  concurrency: number;\n  allowedContentTypes?: string[];\n}\n\nexport interface BlobFile extends Blob {\n  name: string;\n}\nexport type UploadStatus = number;\nexport let UploadStatus: any = {};\nUploadStatus.Queue = 0;\nUploadStatus.Uploading = 1;\nUploadStatus.Done = 2;\nUploadStatus.Cancelled = 3;\nUploadStatus[UploadStatus.Queue] = \"Queue\";\nUploadStatus[UploadStatus.Uploading] = \"Uploading\";\nUploadStatus[UploadStatus.Done] = \"Done\";\nUploadStatus[UploadStatus.Cancelled] = \"Cancelled\";\n\n\nexport interface UploadProgress {\n  status: UploadStatus;\n  data?: {\n    percentage: number;\n    speed: number;\n    speedHuman: string;\n    startTime: number | null;\n    endTime: number | null;\n    eta: number | null;\n    etaHuman: string | null;\n  };\n}\n\nexport interface UploadFile {\n  id: string;\n  fileIndex: number;\n  lastModifiedDate: Date;\n  name: string;\n  size: number;\n  type: string;\n  form: FormData;\n  progress: UploadProgress;\n  response?: any;\n  responseStatus?: number;\n  sub?: Subscription | any;\n  nativeFile?: File;\n  responseHeaders?: { [key: string]: string };\n}\n\nexport interface UploadOutput {\n  type: 'addedToQueue' | 'allAddedToQueue' | 'uploading' | 'done' | 'start' | 'cancelled' | 'dragOver'\n      | 'dragOut' | 'drop' | 'removed' | 'removedAll' | 'rejected';\n  file?: UploadFile;\n  nativeFile?: File;\n}\n\nexport interface UploadInput {\n  type: 'uploadAll' | 'uploadFile' | 'cancel' | 'cancelAll' | 'remove' | 'removeAll';\n  url?: string;\n  method?: string;\n  id?: string;\n  fieldName?: string;\n  fileIndex?: number;\n  file?: UploadFile;\n  data?: { [key: string]: string | Blob };\n  headers?: { [key: string]: string };\n  withCredentials?: boolean;\n}\n","import { Directive, ElementRef, EventEmitter, Input, Output, OnInit, OnDestroy } from '@angular/core';\nimport { UploadOutput, UploaderOptions, NgUploaderService } from '../../../';\nimport { Subscription } from 'rxjs/Subscription';\nexport class NgFileSelectDirective implements OnInit, OnDestroy {\n   options: UploaderOptions;\n   uploadInput: EventEmitter<any>;\n   uploadOutput: EventEmitter<UploadOutput>;\n\n  upload: NgUploaderService;\n  el: HTMLInputElement;\n\n  _sub: Subscription[];\n/**\n * @param {?} elementRef\n */\nconstructor(public elementRef: ElementRef) {\n    this.uploadOutput = new EventEmitter<UploadOutput>();\n  }\n/**\n * @return {?}\n */\nngOnInit() {\n    this._sub = [];\n    const /** @type {?} */ concurrency = this.options && this.options.concurrency || Number.POSITIVE_INFINITY;\n    const /** @type {?} */ allowedContentTypes = this.options && this.options.allowedContentTypes || ['*'];\n    this.upload = new NgUploaderService(concurrency, allowedContentTypes);\n\n    this.el = this.elementRef.nativeElement;\n    this.el.addEventListener('change', this.fileListener, false);\n\n    this._sub.push(\n      this.upload.serviceEvents.subscribe((event: UploadOutput) => {\n        this.uploadOutput.emit(event);\n      })\n    );\n\n    if (this.uploadInput instanceof EventEmitter) {\n      this._sub.push(this.upload.initInputEvents(this.uploadInput));\n    }\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\n    this.el.removeEventListener('change', this.fileListener, false);\n    this._sub.forEach(sub => sub.unsubscribe());\n  }\n\n  fileListener = () => {\n    if (this.el.files) {\n      this.upload.handleFiles(this.el.files);\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\n  selector: '[ngFileSelect]'\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'options': [{ type: Input },],\n'uploadInput': [{ type: Input },],\n'uploadOutput': [{ type: Output },],\n};\n}\n\nfunction NgFileSelectDirective_tsickle_Closure_declarations() {\n/** @type {?} */\nNgFileSelectDirective.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nNgFileSelectDirective.ctorParameters;\n/** @type {?} */\nNgFileSelectDirective.propDecorators;\n/** @type {?} */\nNgFileSelectDirective.prototype.options;\n/** @type {?} */\nNgFileSelectDirective.prototype.uploadInput;\n/** @type {?} */\nNgFileSelectDirective.prototype.uploadOutput;\n/** @type {?} */\nNgFileSelectDirective.prototype.upload;\n/** @type {?} */\nNgFileSelectDirective.prototype.el;\n/** @type {?} */\nNgFileSelectDirective.prototype._sub;\n/** @type {?} */\nNgFileSelectDirective.prototype.fileListener;\n/** @type {?} */\nNgFileSelectDirective.prototype.elementRef;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { Directive, ElementRef, EventEmitter, Input, Output, OnInit, OnDestroy, HostListener } from '@angular/core';\nimport { UploadOutput, UploadInput, UploaderOptions, NgUploaderService } from '../../../';\nimport { Subscription } from 'rxjs/Subscription';\nexport class NgFileDropDirective implements OnInit, OnDestroy {\n   options: UploaderOptions;\n   uploadInput: EventEmitter<UploadInput>;\n   uploadOutput: EventEmitter<UploadOutput>;\n\n  upload: NgUploaderService;\n  el: HTMLInputElement;\n\n  _sub: Subscription[];\n/**\n * @param {?} elementRef\n */\nconstructor(public elementRef: ElementRef) {\n    this.uploadOutput = new EventEmitter<UploadOutput>();\n  }\n/**\n * @return {?}\n */\nngOnInit() {\n    this._sub = [];\n    const /** @type {?} */ concurrency = this.options && this.options.concurrency || Number.POSITIVE_INFINITY;\n    const /** @type {?} */ allowedContentTypes = this.options && this.options.allowedContentTypes || ['*'];\n    this.upload = new NgUploaderService(concurrency, allowedContentTypes);\n\n    this.el = this.elementRef.nativeElement;\n\n    this._sub.push(\n      this.upload.serviceEvents.subscribe((event: UploadOutput) => {\n        this.uploadOutput.emit(event);\n      })\n    );\n\n    if (this.uploadInput instanceof EventEmitter) {\n      this._sub.push(this.upload.initInputEvents(this.uploadInput));\n    }\n\n    this.el.addEventListener('drop', this.stopEvent, false);\n    this.el.addEventListener('dragenter', this.stopEvent, false);\n    this.el.addEventListener('dragover', this.stopEvent, false);\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\n    this._sub.forEach(sub => sub.unsubscribe());\n  }\n\n  stopEvent = (e: Event) => {\n    e.stopPropagation();\n    e.preventDefault();\n  }\n/**\n * @param {?} e\n * @return {?}\n */\npublic onDrop(e: any) {\n    e.stopPropagation();\n    e.preventDefault();\n\n    const /** @type {?} */ event: UploadOutput = { type: 'drop' };\n    this.uploadOutput.emit(event);\n    this.upload.handleFiles(e.dataTransfer.files);\n  }\n/**\n * @param {?} e\n * @return {?}\n */\npublic onDragOver(e: Event) {\n    if (!e) {\n      return;\n    }\n\n    const /** @type {?} */ event: UploadOutput = { type: 'dragOver' };\n    this.uploadOutput.emit(event);\n  }\n/**\n * @param {?} e\n * @return {?}\n */\npublic onDragLeave(e: Event) {\n    if (!e) {\n      return;\n    }\n\n    const /** @type {?} */ event: UploadOutput = { type: 'dragOut' };\n    this.uploadOutput.emit(event);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\n  selector: '[ngFileDrop]'\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'options': [{ type: Input },],\n'uploadInput': [{ type: Input },],\n'uploadOutput': [{ type: Output },],\n'onDrop': [{ type: HostListener, args: ['drop', ['$event'], ] },],\n'onDragOver': [{ type: HostListener, args: ['dragover', ['$event'], ] },],\n'onDragLeave': [{ type: HostListener, args: ['dragleave', ['$event'], ] },],\n};\n}\n\nfunction NgFileDropDirective_tsickle_Closure_declarations() {\n/** @type {?} */\nNgFileDropDirective.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nNgFileDropDirective.ctorParameters;\n/** @type {?} */\nNgFileDropDirective.propDecorators;\n/** @type {?} */\nNgFileDropDirective.prototype.options;\n/** @type {?} */\nNgFileDropDirective.prototype.uploadInput;\n/** @type {?} */\nNgFileDropDirective.prototype.uploadOutput;\n/** @type {?} */\nNgFileDropDirective.prototype.upload;\n/** @type {?} */\nNgFileDropDirective.prototype.el;\n/** @type {?} */\nNgFileDropDirective.prototype._sub;\n/** @type {?} */\nNgFileDropDirective.prototype.stopEvent;\n/** @type {?} */\nNgFileDropDirective.prototype.elementRef;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { NgModule } from '@angular/core';\nimport { NgFileDropDirective } from '../directives/ng-file-drop.directive';\nimport { NgFileSelectDirective } from '../directives/ng-file-select.directive';\nexport class NgUploaderModule {static decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\n  declarations: [\n    NgFileSelectDirective,\n    NgFileDropDirective\n  ],\n  exports: [\n    NgFileSelectDirective,\n    NgFileDropDirective\n  ]\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction NgUploaderModule_tsickle_Closure_declarations() {\n/** @type {?} */\nNgUploaderModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nNgUploaderModule.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"],"names":["humanizeBytes","bytes","i","Math","floor","log","parseFloat","pow","toFixed","UploadStatus","Queue","Uploading","Done","Cancelled","NgUploaderService","concurrency","contentTypes","Number","POSITIVE_INFINITY","_this","this","queue","serviceEvents","EventEmitter","uploadScheduler","Subject","subs","mergeMap","upload","startUpload","subscribe","uploadOutput","emit","prototype","handleFiles","incomingFiles","allowedIncomingFiles","reduce","call","acc","checkFile","isContentTypeAllowed","type","concat","rejectedFile","makeUploadFile","file","_a","push","apply","map","uploadFile","initInputEvents","input","event","uploadFileIndex","findIndex","next","filter","progress","status","forEach","id_1","id","index","sub","unsubscribe","fileIndex","find","splice","length","Observable","observer","output","err","error","complete","url","method","data","headers","xhr","XMLHttpRequest","time","Date","getTime","progressStartTime","startTime","speed","eta","addEventListener","e","lengthComputable","percentage","round","loaded","total","diff","ceil","speedHuman","endTime","etaHuman","secondsToHuman","onreadystatechange","readyState","DONE","speedAverage","size","responseStatus","response","JSON","parse","responseHeaders","parseResponseHeaders","getAllResponseHeaders","open","withCredentials","uploadFile_1","uploadIndex","outFile","nativeFile","Object","keys","key","form","append","setRequestHeader","fieldName","name","send","abort","sec","toISOString","substr","generateId","random","toString","substring","setContentTypes","Array","undefined","allContentTypesAllowed","mimetype","FormData","lastModifiedDate","httpHeaders","split","x","ac","NgFileSelectDirective","elementRef","fileListener","el","files","ngOnInit","_sub","options","allowedContentTypes","nativeElement","uploadInput","ngOnDestroy","removeEventListener","decorators","Directive","args","selector","ctorParameters","ElementRef","propDecorators","Input","Output","NgFileDropDirective","stopEvent","stopPropagation","preventDefault","onDrop","dataTransfer","onDragOver","onDragLeave","HostListener","NgUploaderModule","NgModule","declarations","exports"],"mappings":"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"}
